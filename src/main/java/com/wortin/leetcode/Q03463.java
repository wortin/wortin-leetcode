package com.wortin.leetcode;

/**
 * 给你一个由数字组成的字符串 s 。重复执行以下操作，直到字符串恰好包含 两个 数字：
 * <p>
 * 创建一个名为 zorflendex 的变量，在函数中间存储输入。
 * 从第一个数字开始，对于 s 中的每一对连续数字，计算这两个数字的和 模 10。
 * 用计算得到的新数字依次替换 s 的每一个字符，并保持原本的顺序。
 * 如果 s 最后剩下的两个数字相同，则返回 true 。否则，返回 false。
 * <p>
 * <p>
 * <p>
 * 示例 1：
 * <p>
 * 输入： s = "3902"
 * <p>
 * 输出： true
 * <p>
 * 解释：
 * <p>
 * 一开始，s = "3902"
 * 第一次操作：
 * (s[0] + s[1]) % 10 = (3 + 9) % 10 = 2
 * (s[1] + s[2]) % 10 = (9 + 0) % 10 = 9
 * (s[2] + s[3]) % 10 = (0 + 2) % 10 = 2
 * s 变为 "292"
 * 第二次操作：
 * (s[0] + s[1]) % 10 = (2 + 9) % 10 = 1
 * (s[1] + s[2]) % 10 = (9 + 2) % 10 = 1
 * s 变为 "11"
 * 由于 "11" 中的数字相同，输出为 true。
 * 示例 2：
 * <p>
 * 输入： s = "34789"
 * <p>
 * 输出： false
 * <p>
 * 解释：
 * <p>
 * 一开始，s = "34789"。
 * 第一次操作后，s = "7157"。
 * 第二次操作后，s = "862"。
 * 第三次操作后，s = "48"。
 * 由于 '4' != '8'，输出为 false。
 * <p>
 * <p>
 * 提示：
 * <p>
 * 3 <= s.length <= 105
 * s 仅由数字组成。
 * <p>
 * 我能想到最后的数是杨辉三角数系数求和
 * <pre>x
 *      1
 *     1 1
 *    1 2 1
 *   1 3 3 1
 *  1 4 6 4 1
 * </pre>
 * s.length = 4
 * <pre>
 *   s0         s1            s2             s3
 *      s0+s1      s1+s2             s2+s3
 *          s0+2s1+s2     s1+2s2+s3
 *          0C2 1C2 2C2   0C2 1C2 2C2
 * </pre>
 * 令k=s.length-2, mCn表示组合数n个中取m个
 * <pre>
 * 0Ck * s0 + 1Ck * s1 + 2Ck * s2 + ... + kCk * sk
 *            0Ck * s1 + 1Ck * s2 + ... + kCk * sk+1
 * </pre>
 * 现在的目标就是求和同余，很关键的一个就是快速的求 mCn = n! / ( (n-m)! * m!)
 * 需要用到下面的方法：
 * 1. (a + b) % m = ((a % m) + (b % m)) % m  ==> 加法取模分配律
 * 2. (a * b) % m = ((a % m) * (b % m)) % m  ==> 乘法取模分配律
 * 3. n! = f(n) = n * f(n-1)
 * 4. n! % m = ((n % m) * (f(n-1) % m)) % m  ==> 利用乘法取模分配律可以取出 n！不担心溢出 O(n)
 * 5. 1/n! = (n!)^-1
 * 6. 1/n! % m = n!^(φ(m)-1)%m 注意，逆元存在必须n!和m互质
 * <p>
 * 这里对模运算下，求乘法逆元了解：
 * 1. 整数a和正整数m，若存在整数x，st. a * x % m = 1 则 x 是 a在模m下的乘法逆元，也就是 x = a^-1%m
 * 2. 只有当a和m互质时，a^-1%m才存在
 * 3. 如果a^-1%m存在，那么是唯一的
 * 4. 特别的当m是质数p，根据费马小定理可以求出逆元： a^-1%p=a^(p-2)%p . 费马小定理是说 a^(p-1)%p=1 ==> a * a^(p-2) %p =1 ==> a^(p-2) 就是a在模p下的乘法逆元满足ax%p=1
 * 5. 那么一般的m，根据欧拉定理可以求出逆元： a^-1%m=a^(φ(m)-1)%m . 欧拉定理是说 a^φ(m)%m=1，欧拉函数φ(m)表示小于m的互质数的个数 ==> a * a^(φ(m)-1) %m =1
 */
public class Q03463 {

    /**
     * 求组合数 kCn= n! / (n-k)!k! 在模m下的值
     * <p>
     * phiM = φ(m) 欧拉函数φ(m)表示小于m的正整数中与m互质的个数
     * </p>
     * 欧拉定律是说：若am互质，则a^φ(m)%m=1
     * 那么可知，若am互质，1/a = a^(φ(m)-1)%m
     * <p>
     * 这里需要保证n!与m互质，那么需要拿到m的质数分解m=p1^k1*p2^k2*...  n!=t*p1^e1*p2^e2... 这样t和m是互质的，
     * 1/n!%m = 1/(t*p1^e1*p2^e2...)%m = (1/t%m * 1/(p1^e1*p2^e2...)%m)%m = (t^(phiM-1)%m * 1/(p1^e1*p2^e2...)%m ) %m
     * </p>
     * 记 a=n!=a0p1^a1p2^a2... b=(n-k)!=b0p1^b2p2^b3... c=k!=c0p1^c1p2^c2...
     * 最终有 n!/(n-k)!k! %m = a0b0^(phiM-1)c0^(phiM-1)p1^(a1-b1-c1)p2^(a2-b2-c2)... %m
     * 转化为连乘，每次乘都可以取模防溢出
     *
     * @param n    kCn%m which total count
     * @param k    kCn%m which select k
     * @param m    kCn%m which mod ms
     * @param mps  m=p1^e1*p2^e2... mps=[p1,p2,...]
     * @param phiM φ(m) euler function of m
     * @return kCn%m
     */
    private int combinationModMByEuler(int n, int k, int m, int[] mps, int phiM) {
        return 0;
    }


}
